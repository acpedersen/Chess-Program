/*
 * This class is the base for any pieces that will be created
 * Contains abstract methods designed to be overidden as well as easy ways to access those methods with different parameters
 */

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Reflection;

namespace Chess_Program
{
    public abstract class AbstractPiece
    {
        ///Variables
        private ColorEnum _color;
        private Location _location;
        private bool hasMoved;
        private int VALUE = 0;
        protected System.Drawing.Bitmap whiteVersion, blackVersion;
        
        ///Constructors
        public AbstractPiece()
        {
            setHasMoved(false);
        }
        public AbstractPiece(ColorEnum color, Location location) // Regular constructor
            : this()
        {
            this._color = color;
            this._location = location;
        }
        public AbstractPiece(AbstractPiece copyPiece) // Copy constructor
        {
            this.color = copyPiece.color;
            this.location = copyPiece.location.Copy();
            this.hasMoved = copyPiece.hasMoved;
        }

        ///Properties
        public ColorEnum color
        {
            get { return _color; }
            set { _color = value; }
        }
        public Location location
        {
            get { return _location; }
            set { _location = value; }
        }

        ///Accesors
        public string getPieceType()
        {
            return this.GetType().Name;
        }
        public int getValue()
        {
            return VALUE;
        }
        
        public void setHasMoved(bool value)
        {
            hasMoved = value;
        }
        public bool getHasMoved()
        {
            return hasMoved;
        }

        ///Methods
        /*
         * A couple of methods to create a deep copy of the object
         */
        public AbstractPiece Copy()
        {
            object[] constructor = {this};

            AbstractPiece newPiece = (AbstractPiece)Activator.CreateInstance(this.GetType(), constructor);
            
            return newPiece;
        }
        public static AbstractPiece Copy(AbstractPiece piece)
        {
            return piece.Copy();
        }
        public static IList<AbstractPiece> Copy(IList<AbstractPiece> pieces)
        {
            IList<AbstractPiece> newPieces = new List<AbstractPiece>();
            foreach(AbstractPiece piece in pieces)
            {
                newPieces.Add(piece.Copy());
            }
            return newPieces;
        }
        
        /*
         * Overiding basic operators == != and Equals()
         * This allows for easily comparing the class when programming
         */
        public static bool operator ==(AbstractPiece piece1, AbstractPiece piece2)
        {
            if (object.ReferenceEquals(piece1, null) || object.ReferenceEquals(piece2, null))
            {
                if (object.ReferenceEquals(piece1, piece2))//Both null
                    return true;
                else
                    return false;
            }

            return piece1.Equals(piece2);
        }
        public static bool operator !=(AbstractPiece piece1, AbstractPiece piece2)
        {
            if (object.ReferenceEquals(piece1, null) || object.ReferenceEquals(piece2, null))
            {
                if (object.ReferenceEquals(piece1, piece2))
                    return false;
                else
                    return true;
            }

            return !piece1.Equals(piece2);
        }
        public override bool Equals(object comparison)
        {
            if (comparison == null)
                return false;

            if (comparison.GetType().IsSubclassOf(typeof(AbstractPiece)))
            {
                AbstractPiece piece = (AbstractPiece)comparison;
                if (piece.getPieceType() == this.getPieceType() &&
                    piece.location == this.location &&
                    piece.color == this.color &&
                    piece.hasMoved == this.hasMoved)
                {
                    return true;
                }
            }


            return false;
        }


        /*
         * Takes a move as a parameter and checks if the possible moves generated by getMoves includes it
         */
        public bool checkMove(GameBoard board, Move move)
        {
            return checkMove(board, this.location, move);
        }
        public bool checkMove(GameBoard board, Location startLocation, Move move)
        {
            if(getMoves(board, startLocation, this.color).Contains(move))
            {
                //Valid move
                return true;
            }

            return false;
        }

        /*
         * Gets a list of moves that the piece can make based on its typing from inheriting AbstractPiece with getPieceMoves
         */
        public MoveList getMoves(GameBoard board)
        {
            return getMoves(board, this.location, this.color);
        }
        public MoveList getMoves(GameBoard board, Location startLocation, ColorEnum color)
        {
            return getPieceMoves(board, startLocation, color);
        }
        public abstract MoveList getPieceMoves(GameBoard board, Location startLocation, ColorEnum color);


        //Execute anything that must occur after a move for any piece
        //Meant to be overidden only if there is some specific action
        //Ex. A pawn becoming a Queen at the end of a move if it is at the end of the board
        public virtual void afterMoveAction(GameBoard board)
        {
            //Left blank intentionally as the default is no afterMoveAction
        }

        //Used in getting all Piece Types in the current Assembly
        public static Type[] getDerivedTypes()
        {
            IList<Type> derivedClasses = new List<Type>();
            Type[] types = System.Reflection.Assembly.GetExecutingAssembly().GetTypes();
            foreach (Type type in types)
            {
                if (type.BaseType == typeof(AbstractPiece))
                {
                    derivedClasses.Add(type);
                }
            }

            return derivedClasses.ToArray();
        }

        //For displaying an image to the GameBoard
        public System.Drawing.Bitmap GetPieceImage()
        {
            if(color == ColorEnum.White)
            {
                return whiteVersion;
            }
            else
            {
                return blackVersion;
            }
        }

        //These methods allow for an easily accessible direction for shifting a location depending on their color
        protected int getXForward()
        {
            return getXForward(color);
        }
        protected int getYForward()
        {
            return getYForward(color);
        }
        protected static int getXForward(ColorEnum color)
        {//Unused or unneeded
            return 1;
        }
        protected static int getYForward(ColorEnum color)
        {
            return color == ColorEnum.White ? -1 : 1;
        }

    }
}
